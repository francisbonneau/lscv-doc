<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#visualisation-temps-réel-des-appels-systèmes-linux">Visualisation temps réel des appels systèmes Linux</a><ul>
<li><a href="#chapitre-1-introduction">Chapitre 1 : Introduction</a><ul>
<li><a href="#description-du-projet-en-bref">1.1 Description du projet en bref</a></li>
<li><a href="#contexte">1.2 Contexte</a></li>
<li><a href="#problématique">1.3 Problématique</a></li>
<li><a href="#objectifs">1.4 Objectifs</a></li>
<li><a href="#résultats-attendus">1.5 Résultats attendus</a></li>
</ul></li>
<li><a href="#chapitre-2-analyse-de-la-performance-sous-linux">Chapitre 2 : Analyse de la performance sous Linux</a><ul>
<li><a href="#revue-de-larchitecture-de-linux">2.1 Revue de l'architecture de Linux</a></li>
<li><a href="#méthodologies-de-lanalyse-de-perfomance">2.2 Méthodologies de l'analyse de perfomance</a></li>
<li><a href="#métriques-et-statistiques">2.3 Métriques et statistiques</a></li>
<li><a href="#données-fournies-par-le-kernel">2.4 Données fournies par le Kernel</a></li>
<li><a href="#revue-des-outils-existants">2.5 Revue des outils existants</a></li>
<li><a href="#approches-graphiques">2.6 Approches graphiques</a></li>
</ul></li>
<li><a href="#chapitre-3-visualisation-de-données">Chapitre 3 : Visualisation de données</a><ul>
<li><a href="#objectif">3.1 Objectif</a></li>
<li><a href="#théorie-et-bonnes-pratiques">3.2 Théorie et bonnes pratiques</a></li>
<li><a href="#revue-des-approches-courantes">3.3 Revue des approches courantes</a></li>
<li><a href="#description-de-lapproche-choisie">3.4 Description de l'approche choisie</a></li>
<li><a href="#avantages-et-inconvéniants">3.5 Avantages et inconvéniants</a></li>
<li><a href="#alternatives-possibles">3.6 Alternatives possibles</a></li>
</ul></li>
<li><a href="#chapitre-4-conception-du-logiciel">Chapitre 4 : Conception du logiciel</a><ul>
<li><a href="#défis-rencontrés">4.1 Défis rencontrés</a></li>
<li><a href="#architecture-choisie">4.2 Architecture choisie</a></li>
<li><a href="#diagrammes">4.3 Diagrammes</a></li>
</ul></li>
<li><a href="#chapitre-5-implémentation-du-logiciel">Chapitre 5 : Implémentation du logiciel</a><ul>
<li><a href="#outils-utilisés">5.1 Outils utilisés</a></li>
<li><a href="#méthodologie">5.2 Méthodologie</a></li>
<li><a href="#problèmes-rencontrés">5.3 Problèmes rencontrés</a></li>
<li><a href="#solutions-trouvées">5.4 Solutions trouvées</a></li>
<li><a href="#déploiement-du-logiciel">5.5 Déploiement du logiciel</a></li>
</ul></li>
<li><a href="#chapitre-6-discussion-et-conclusion">Chapitre 6 : Discussion et conclusion</a><ul>
<li><a href="#dicussion">6.1 Dicussion</a></li>
<li><a href="#recommandations">6.2 Recommandations</a></li>
<li><a href="#conclusion">6.3 Conclusion</a></li>
</ul></li>
<li><a href="#annexe">Annexe</a><ul>
<li><a href="#description-des-métriques">Description des métriques</a></li>
</ul></li>
</ul></li>
</ul>
</div>
<h1 id="visualisation-temps-réel-des-appels-systèmes-linux"><a href="#visualisation-temps-réel-des-appels-systèmes-linux">Visualisation temps réel des appels systèmes Linux</a></h1>
<h2 id="chapitre-1-introduction"><a href="#chapitre-1-introduction">Chapitre 1 : Introduction</a></h2>
<h3 id="description-du-projet-en-bref"><a href="#description-du-projet-en-bref">1.1 Description du projet en bref</a></h3>
<p>Ce projet consiste à explorer des différents méthodes de visualisation de données reliées aux systèmes d'exploitation et de proposer une nouvelle option.</p>
<h3 id="contexte"><a href="#contexte">1.2 Contexte</a></h3>
<p>Grand nombre d’entreprises ont des applications en production dont la performance de celles-ci est critique. Les requis de performance de ces applications sont tels qu’une tendance actuelle est de concevoir des architectures de nature distribuées, afin que l’application soit exécutée en parallèle sur plusieurs machines. Or, lorsque cette application ne performe pas à la hauteur des attentes ou qu’un problème survient en production, les administrateurs systèmes et développeurs doivent effectuer un diagnostic et localiser la source du problème.</p>
<h3 id="problématique"><a href="#problématique">1.3 Problématique</a></h3>
<p>Diagnostiquer la source d’un problème de performance d’une application en production, qui est exécutée en parallèle sur différentes machines peut s’avérer une tâche ardue. D’autant plus si cette application fonctionne sur des systèmes d'exploitation (Operating system, ou OS) de type Linux, sur lesquels souvent le seul accès possible est via un simple terminal en mode texte.</p>
<p>Plusieurs outils en ligne commande existent pour examiner l’activité d’un système Linux, ou l’utilisation des différentes ressources de ce système, mais ceux-ci sont généralement très spécifique, c’est-à-dire qu’ils présentent l’activité en détail qu’une seule partie du système ( comme l’activité sur le réseau ) ou alors ils sont plutôt généraliste et ne présentent qu’un léger aperçu de l’activité des différentes parties du système.</p>
<h3 id="objectifs"><a href="#objectifs">1.4 Objectifs</a></h3>
<p>L’objectif du projet est de proposer une alternative aux outils de diagnostic existants afin de faciliter l’analyse et la recherche de problèmes liés à la performance. Cette alternative devrait simplifier la tâche d’interpréter l’activité sur un ou plusieurs systèmes Linux, notamment dans le cas où l’application d’intérêt est de nature distribuée.</p>
<p>De plus, ce projet vise à explorer différentes techniques de visualisation de données afin de permettre à l’utilisateur d’explorer les résultats obtenus avec une interface graphique, une approche différente à la plupart des outils existants.</p>
<h3 id="résultats-attendus"><a href="#résultats-attendus">1.5 Résultats attendus</a></h3>
<ul>
<li><p>Faciliter l’exploration et l’analyse des données</p></li>
<li><p>Faciliter l’analyse de l’activité d’applications sur un ou plusieurs systèmes</p></li>
<li><p>Diagnostic plus rapide des problèmes liés à la performance</p></li>
<li><p>Gain de connaissances sur les applications et systèmes analysés</p></li>
<li><p>Gain de productivité suite à l’amélioration de la performance</p></li>
</ul>
<h2 id="chapitre-2-analyse-de-la-performance-sous-linux"><a href="#chapitre-2-analyse-de-la-performance-sous-linux">Chapitre 2 : Analyse de la performance sous Linux</a></h2>
<h3 id="revue-de-larchitecture-de-linux"><a href="#revue-de-larchitecture-de-linux">2.1 Revue de l'architecture de Linux</a></h3>
<p>Pour obtenir des données sur l'activité d'une application précise il faut idéalement avoir en premier lieu une compréhension de l'environnement où est exécutée cette application, soit le système d'exploitation. Dans ce projet l'emphase est mise sur les sytèmes d'exploitations UNIX de type Linux, mais les principes de base restent les mêmes entre les différents OS.</p>
<p>De manière générale, un <a href="http://fr.wikipedia.org/wiki/Syst%C3%A8me_d%27exploitation">système d'exploitation</a> sert d'interface entre l'accès au ressources d'une machine et les usagers et applications qui veulent utiliser ces ressources. Grâce à cette interface, les applications peuvent bénéficier de plusieurs services offerts par le système d'exploitation, tel l'ordonnancement, le système de fichier, la sécurité, etc.</p>
<p>Le matériel physique de la machine est donc géré par le système d'exploitation, ou plus précisément <a href="http://fr.wikipedia.org/wiki/Noyau_de_syst%C3%A8me_d%27exploitation">le <em>Kernel</em></a> ou noyau. En pratique, pour que cette abstraction entre la matériel et les applications soit respectée, le système d'exploitation est généralement divisé en deux sections, l'espace utilisateur et l'espace Kernel.</p>
<p>Les applications des usagers sont alors exécutées dans l'espace utilisateur, où les permissions sont restreintes, et doivent demander la permissions au Kernel pour accéder aux ressources. Ces demandes sont nommées <a href="http://fr.wikipedia.org/wiki/Appel_syst%C3%A8me">appels systèmes</a>, ou <em>system calls</em> voire syscalls. Au débuts de UNIX il y avait approximativement 80 appels systèmes, aujourd'hui ce nombre s'élève à plus de 300.</p>
<p>Parmi les appels systèmes les plus courants il y a <a href="http://linux.die.net/man/2/read"><em>read</em></a> et son équivalent <a href="http://linux.die.net/man/2/write"><em>write</em></a> qui permet de lire et d'écrire dans un <em>file descriptor</em>, typiquement un fichier sur le disque. La liste complète est diponible sur plusieurs sites tels que <a href="http://syscalls.kernelgrok.com/">kernelgrok.com</a>, et de l'information spécifique sur chaque appel système est disponible dans le manuel du OS (man), typiquement dans la section numéro 2. Ex : <code>man 2 read</code> </p>
<p>Cette architecture divisées en espaces usager/kernel est souvent représentée de la manière suivante :</p>
<div class="figure">
<img src="figures/linux_arch.png" alt="Fig 1. Architecture de Linux" /><p class="caption">Fig 1. Architecture de Linux</p>
</div>
<p>Tel qu'illustré sur la figure précédentes, les applications exécutées par les usagers d'une machine sont le dernier maillon de la chaine, et produisent le résultat attendu. Celles-ci ne peuvent toutefois fonctionner sans l'appui de tous les services implémentés par le système, services que l'application utilise par le biais de librairies ou d'appels systèmes directement.</p>
<p>Le principal avantage d'une telle architecture est qu'elle permet d'éviter ou de limiter la duplication d'effort. En effet, les développeurs d'applications peuvent se fier aux services offerts par le sytème d'exploitation et n'ont pas besoin de ce soucier de problèmes liés à la gestion du matériel par example, et éviter d'y consacrer des efforts puisque ces problèmes sont déjà gérés par le OS. Tel que l'a souvent répété <a href="https://en.wikipedia.org/wiki/David_Wheeler_(British_computer_scientist)">David Wheeler</a>, un éminent chercheur en informatique :</p>
<blockquote>
<p>All problems in computer science can be solved by another level of indirection</p>
</blockquote>
<p>Les couches d'abstrations, ou d'indirection, offertes par les OS suivent également cette idée.</p>
<p>Or puisque qu'en pratique les applications n'ont pas besoin de ce soucier de l'implémentation de ces couches sous-jacentes, pourquoi s'y intéresser lors de l'analyse de la performance de ces applications ? Cela dépend pricipalement du type d'analyse considéré. Lors de l'établisement d'indice de références, <em>benchmarks</em>, de la performance d'une application spécifique, le matériel et le système d'exploitation peuvent être ignorés - à la seule condition que les autres tests comparatifs soient réalisés sur le même exact environnement, pour qu'ils soient valides.</p>
<p>Toutefois, lorsque l'objectif est d'améliorer la performance d'une application donnée, ou de résoudre un problème lié à la performance, tout doit être pris en considération. Les résultats obtenus vont varier considérablement selon l'environnement, qu'il s'agisse des différentes couches logicelles - de l'application elle-même jusqu'au Kernel, ou alors du matériel de la machine. De plus, lors de problèmes de performance, si la cause est due à du matériel ou des périphériques fautifs, alors c'est au niveau du OS qu'il faut regarder, car l'application elle-même ne connait pas l'état de la machine sur laquelle elle fonctionne.</p>
<h3 id="méthodologies-de-lanalyse-de-perfomance"><a href="#méthodologies-de-lanalyse-de-perfomance">2.2 Méthodologies de l'analyse de perfomance</a></h3>
<p>Ce projet s'intéresse principalement aux analyses de performance reliées à l'amélioration ou la résolution de problèmes, et l'objectif final est de permettre à l'utilisateur d'en apprendre plus sur son application et la façon dont elle intéragit avec le OS pour améliorer celle-ci. L'établissement d'indices de performances, ou <em>benchmarks</em> ne sera pas considéré. Ceci dit, explorons les différentes techniques liées à ces types d'analyses.</p>
<p>Dans son livre <em>Systems Performance: Enterprise and the Cloud</em>, Bredan Gregg propose différentes méthodologies pour procéder à la résolution de problèmes de performance. Celles-ci sont également détaillées sur son site web : <a href="http://www.brendangregg.com/methodology.html">brendangregg.com/methodology.html</a>. En voici quelques unes :</p>
<blockquote>
<ol start="6" style="list-style-type: decimal">
<li>Ad Hoc Checklist Method</li>
<li>Problem Statement Method</li>
<li>Scientific Method</li>
<li>Workload Characterization Method</li>
<li>Drill-Down Analysis Method</li>
<li>Five Whys Performance Method</li>
<li>By-Layer Method</li>
<li>Latency Analysis Method</li>
<li>Tools Method</li>
<li>USE Method<br />[...]</li>
</ol>
</blockquote>
<p>Deux méthodologies seront principalement utilisées dans le cadre du projet, soit la méthdode de caractérisation de la charge de travail <em>Workload Characterization Method</em>, et la méthode d'analyse par exploration <em>Drill-Down Analysis Method</em>. La caractérisation de la charge de travail consiste à identifier la source et la nature de la charge sur un système, et de suivre son évolution à travers le temps. Un changement soudain de la charge comparée à l'historique peut alors indiquer un problème potentiel, et l'identification du type de charge peut ensuite pointer vers la source. De manière générale, l'analyse par exploration, <em>Drill-Down</em>, consiste à examiner une vue d'ensemble d'un système, pour ensuite explorer plus en profondeur les détails d'un secteur d'intérêt en particulier.</p>
<p>En effet, la solution proposée devrait permettre à un utilisateur de voir une vue d'ensemble du système analysé, et de permettre à cet utilisateur de sélectioner une partie du système qu'il l'intéresse, pour rafiner la vue affichée pour afficher les détails de cette partie. Une <em>vue</em> devrait idéalement permettre à l'usager de caractériser visuellement la charge de travail présente sur le système, et possiblement de comparer la charge actuelle à un historique.</p>
<h3 id="métriques-et-statistiques"><a href="#métriques-et-statistiques">2.3 Métriques et statistiques</a></h3>
<p>Les métriques de performance sont des statisques qui mesurent l'activité de différentes parties du système. Généralement il s'agit d'un pourcentage d'utilisation, un nombre d'opérations par intervale de temps (typiquement des secondes, ex : IOPS, I/O operations per second), ou alors le temps de latence associé à une certaine opération. Le métriques peuvent être caculés directement par le système d'exploitation ou par des applications distinctes.</p>
<p>Une très grande quantité de métrique peut être collectée à un temps donné sur un système d'exploitation, sans parler des métriques spécifique aux applications, cela peut résulter en une quantité considérable de données à analyser. Il est toutefois possible d'identifier quelques métriques clés qui peuvent donner une très bonne idée de l'état d'un système. À titre d'exemple, le <em>Redpaper</em> de IBM intitulé <a href="http://www.redbooks.ibm.com/redpapers/pdfs/redp4285.pdf"><em>Linux Performance and Tuning Guidelines</em></a> décrit pour Linux les métriques suivants (descriptions en annexe) :</p>
<table>
<thead>
<tr class="header">
<th align="left">Processor metrics</th>
<th align="left">Memory metrics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="#cpu-utilization">CPU utilization</a></td>
<td align="left"><a href="#free-memory">Free memory</a></td>
</tr>
<tr class="even">
<td align="left"><a href="#user-time">User time</a></td>
<td align="left"><a href="#swap-usage">Swap usage</a></td>
</tr>
<tr class="odd">
<td align="left"><a href="#system-time">System time</a></td>
<td align="left"><a href="#buffer-and-cache">Buffer and cache</a></td>
</tr>
<tr class="even">
<td align="left"><a href="#waiting-time">Waiting time</a></td>
<td align="left"><a href="#slabs">Slabs</a></td>
</tr>
<tr class="odd">
<td align="left"><a href="#idle-time">Idle time</a></td>
<td align="left"><a href="#active-vs-inactive-memory">Active vs inactive memory</a></td>
</tr>
<tr class="even">
<td align="left"><a href="#nice-time">Nice time</a></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><a href="#load-average">Load average</a></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><a href="#runnable-processes">Runable processes</a></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><a href="#blocked-processes">Blocked processes</a></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><a href="#context-swiches">Context switches</a></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><a href="#interrups">Interrupts</a></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th align="left">Network interface metrics</th>
<th align="left">Block device metrics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="#packets-received-and-sent">Packets received and sent</a></td>
<td align="left"><a href="#iowait">IOwait</a></td>
</tr>
<tr class="even">
<td align="left"><a href="#bytes-received-and-sent">Bytes received and sent</a></td>
<td align="left"><a href="#average-queue-length">Average queue length</a></td>
</tr>
<tr class="odd">
<td align="left"><a href="#collisions-per-second">Collisions per second</a></td>
<td align="left"><a href="#average-wait">Average wait</a></td>
</tr>
<tr class="even">
<td align="left"><a href="#packets-dropped">Packets dropped</a></td>
<td align="left"><a href="#transferts-per-second">Transfers per second</a></td>
</tr>
<tr class="odd">
<td align="left"><a href="#overruns">Overruns</a></td>
<td align="left"><a href="#blocks-readwrite-per-second">Blocks read/write per second</a></td>
</tr>
<tr class="even">
<td align="left"><a href="#errors">Errors</a></td>
<td align="left"><a href="#kilobytes-per-second-readwrite">Kilobytes per second read/write</a></td>
</tr>
</tbody>
</table>
<p>Les métriques sont surtout utile lorsqu'on peut les comparer à un historique, et alors constater soit une dégradation ou une amélioration de la performance.</p>
<p>En pratique, collecter une grande quantité de métriques sur un système en production peut s'avérer utile lors de la résolution de problèmes, mais cela à un certain coût additionnel sur le système instrumenté, qui dépendament des cas, peut performer moins efficacement.</p>
<p>Une alternative pourrait être de collecter tous les métriques durant une certaine période, cibler ceux qui sont réelement d'intérêt et de se limiter à ceux-là en production. Rien n'empêche également d'activer l'instrumentation maximale suite à un changement dans le système tel un nouveau déploiement, et réduire par la suite l'instrumentation du système une fois sa stabilité établie.</p>
<h3 id="données-fournies-par-le-kernel"><a href="#données-fournies-par-le-kernel">2.4 Données fournies par le Kernel</a></h3>
<div class="figure">
<img src="figures/proc.png" alt="Fig 2. Aperçu de /proc/" /><p class="caption">Fig 2. Aperçu de /proc/</p>
</div>
<h3 id="revue-des-outils-existants"><a href="#revue-des-outils-existants">2.5 Revue des outils existants</a></h3>
<h3 id="approches-graphiques"><a href="#approches-graphiques">2.6 Approches graphiques</a></h3>
<h2 id="chapitre-3-visualisation-de-données"><a href="#chapitre-3-visualisation-de-données">Chapitre 3 : Visualisation de données</a></h2>
<h3 id="objectif"><a href="#objectif">3.1 Objectif</a></h3>
<h3 id="théorie-et-bonnes-pratiques"><a href="#théorie-et-bonnes-pratiques">3.2 Théorie et bonnes pratiques</a></h3>
<h3 id="revue-des-approches-courantes"><a href="#revue-des-approches-courantes">3.3 Revue des approches courantes</a></h3>
<h3 id="description-de-lapproche-choisie"><a href="#description-de-lapproche-choisie">3.4 Description de l'approche choisie</a></h3>
<h3 id="avantages-et-inconvéniants"><a href="#avantages-et-inconvéniants">3.5 Avantages et inconvéniants</a></h3>
<h3 id="alternatives-possibles"><a href="#alternatives-possibles">3.6 Alternatives possibles</a></h3>
<h2 id="chapitre-4-conception-du-logiciel"><a href="#chapitre-4-conception-du-logiciel">Chapitre 4 : Conception du logiciel</a></h2>
<h3 id="défis-rencontrés"><a href="#défis-rencontrés">4.1 Défis rencontrés</a></h3>
<h3 id="architecture-choisie"><a href="#architecture-choisie">4.2 Architecture choisie</a></h3>
<h3 id="diagrammes"><a href="#diagrammes">4.3 Diagrammes</a></h3>
<h2 id="chapitre-5-implémentation-du-logiciel"><a href="#chapitre-5-implémentation-du-logiciel">Chapitre 5 : Implémentation du logiciel</a></h2>
<h3 id="outils-utilisés"><a href="#outils-utilisés">5.1 Outils utilisés</a></h3>
<h3 id="méthodologie"><a href="#méthodologie">5.2 Méthodologie</a></h3>
<h3 id="problèmes-rencontrés"><a href="#problèmes-rencontrés">5.3 Problèmes rencontrés</a></h3>
<h3 id="solutions-trouvées"><a href="#solutions-trouvées">5.4 Solutions trouvées</a></h3>
<h3 id="déploiement-du-logiciel"><a href="#déploiement-du-logiciel">5.5 Déploiement du logiciel</a></h3>
<h2 id="chapitre-6-discussion-et-conclusion"><a href="#chapitre-6-discussion-et-conclusion">Chapitre 6 : Discussion et conclusion</a></h2>
<h3 id="dicussion"><a href="#dicussion">6.1 Dicussion</a></h3>
<h3 id="recommandations"><a href="#recommandations">6.2 Recommandations</a></h3>
<h3 id="conclusion"><a href="#conclusion">6.3 Conclusion</a></h3>
<h2 id="annexe"><a href="#annexe">Annexe</a></h2>
<h3 id="description-des-métriques"><a href="#description-des-métriques">Description des métriques</a></h3>
<p>Tirées de http://www.redbooks.ibm.com/redpapers/pdfs/redp4285.pdf</p>
<h4 id="cpu-utilization"><a href="#cpu-utilization">CPU utilization</a></h4>
<p>This is probably the most straightforward metric. It describes the overall utilization per processor. On IBM System x architectures, if the CPU utilization exceeds 80% for a sustained period of time, a processor bottleneck is likely.</p>
<h4 id="user-time"><a href="#user-time">User time</a></h4>
<p>Depicts the CPU percentage spent on user processes, including nice time. High values in user time are generally desirable because, in this case, the system performs actual work.</p>
<h4 id="system-time"><a href="#system-time">System time</a></h4>
<p>Depicts the CPU percentage spent on kernel operations including IRQ and softirq time. High and sustained system time values can point you to bottlenecks in the network and driver stack. A system should generally spend as little time as possible in kernel time.</p>
<h4 id="waiting-time"><a href="#waiting-time">Waiting time</a></h4>
<p>Total amount of CPU time spent waiting for an I/O operation to occur. Like the blocked value, a system should not spend too much time waiting for I/O operations; otherwise you should investigate the performance of the respective I/O subsystem.</p>
<h4 id="idle-time"><a href="#idle-time">Idle time</a></h4>
<p>Depicts the CPU percentage the system was idle waiting for tasks.</p>
<h4 id="nice-time"><a href="#nice-time">Nice time</a></h4>
<p>Depicts the CPU percentage spent on re-nicing processes that change the execution order and priority of processes.</p>
<h4 id="load-average"><a href="#load-average">Load average</a></h4>
<p>The load average is not a percentage, but the rolling average of the sum of the following:</p>
<p>– The number of processes in queue waiting to be processed</p>
<p>– The number of processes waiting for uninterruptable task to be completed</p>
<p>That is, the average of the sum of TASK_RUNNING and TASK_UNINTERRUPTIBLE processes. If processes that request CPU time are blocked (which means that the CPU has no time to process them), the load average will increase. On the other hand, if each process gets immediate access to CPU time and there are no CPU cycles lost, the load will decrease.</p>
<h4 id="runable-processes"><a href="#runable-processes">Runable processes</a></h4>
<p>This value depicts the processes that are ready to be executed. This value should not exceed 10 times the amount of physical processors for a sustained period of time; otherwise a processor bottleneck is likely.</p>
<h4 id="blocked-processes"><a href="#blocked-processes">Blocked processes</a></h4>
<p>Processes that cannot execute while they are waiting for an I/O operation to finish. Blocked processes can point you toward an I/O bottleneck.</p>
<h4 id="context-switches"><a href="#context-switches">Context switches</a></h4>
<p>Amount of switches between threads that occur on the system. High numbers of context switches in connection with a large number of interrupts can signal driver or application issues. Context switches generally are not desirable because the CPU cache is flushed with each one, but some context switching is necessary. Refer to 1.1.5, “Context switching” on page 5.</p>
<h4 id="interrupts"><a href="#interrupts">Interrupts</a></h4>
<p>The interrupt value contains hard interrupts and soft interrupts. Hard interrupts have a more adverse effect on system performance. High interrupt values are an indication of a software bottleneck, either in the kernel or a driver. Remember that the interrupt value includes the interrupts caused by the CPU clock. Refer to 1.1.6, “Interrupt handling” on page 6.</p>
<h4 id="free-memory"><a href="#free-memory">Free memory</a></h4>
<p>Compared to most other operating systems, the free memory value in Linux should not be a cause for concern. As explained in 1.2.2, “Virtual memory manager” on page 12, the Linux kernel allocates most unused memory as file system cache, so subtract the amount of buffers and cache from the used memory to determine (effectively) free memory.</p>
<h4 id="swap-usage"><a href="#swap-usage">Swap usage</a></h4>
<p>This value depicts the amount of swap space used. As described in 1.2.2, “Virtual memory manager” on page 12, swap usage only tells you that Linux manages memory really efficiently. Swap In/Out is a reliable means of identifying a memory bottleneck. Values above 200 to 300 pages per second for a sustained period of time express a likely memory bottleneck.</p>
<h4 id="buffer-and-cache"><a href="#buffer-and-cache">Buffer and cache</a></h4>
<p>Cache allocated as file system and block device cache.</p>
<h4 id="slabs"><a href="#slabs">Slabs</a></h4>
<p>Depicts the kernel usage of memory. Note that kernel pages cannot be paged out to disk.</p>
<h4 id="active-vs-inactive-memory"><a href="#active-vs-inactive-memory">Active vs inactive memory</a></h4>
<p>Provides you with information about the active use of the system memory. Inactive memory is a likely candidate to be swapped out to disk by the kswapd daemon. Refer to “Page frame reclaiming” on page 14.</p>
<h4 id="packets-received-and-sent"><a href="#packets-received-and-sent">Packets received and sent</a></h4>
<p>This metric informs you of the quantity of packets received and sent by a given network interface.</p>
<h4 id="bytes-received-and-sent"><a href="#bytes-received-and-sent">Bytes received and sent</a></h4>
<p>This value depicts the number of bytes received and sent by a given network interface.</p>
<h4 id="collisions-per-second"><a href="#collisions-per-second">Collisions per second</a></h4>
<p>This value provides an indication of the number of collisions that occur on the network that the respective interface is connected to. Sustained values of collisions often concern a bottleneck in the network infrastructure, not the server. On most properly configured networks, collisions are very rare unless the network infrastructure consists of hubs.</p>
<h4 id="packets-dropped"><a href="#packets-dropped">Packets dropped</a></h4>
<p>This is a count of packets that have been dropped by the kernel, either due to a firewall configuration or due to a lack of network buffers.</p>
<h4 id="overruns"><a href="#overruns">Overruns</a></h4>
<p>Overruns represent the number of times that the network interface ran out of buffer space. This metric should be used in conjunction with the packets dropped value to identify a possible bottleneck in network buffers or the network queue length.</p>
<h4 id="errors"><a href="#errors">Errors</a></h4>
<p>The number of frames marked as faulty. This is often caused by a network mismatch or a partially broken network cable. Partially broken network cables can be a significant performance issue for copper-based gigabit networks.</p>
<h4 id="iowait"><a href="#iowait">IOwait</a></h4>
<p>Time the CPU spends waiting for an I/O operation to occur. High and sustained values most likely indicate an I/O bottleneck.</p>
<h4 id="average-queue-length"><a href="#average-queue-length">Average queue length</a></h4>
<p>Amount of outstanding I/O requests. In general, a disk queue of 2 to 3 is optimal; higher values might point toward a disk I/O bottleneck.</p>
<h4 id="average-wait"><a href="#average-wait">Average wait</a></h4>
<p>A measurement of the average time in ms it takes for an I/O request to be serviced. The wait time consists of the actual I/O operation and the time it waited in the I/O queue.</p>
<h4 id="transfers-per-second"><a href="#transfers-per-second">Transfers per second</a></h4>
<p>Depicts how many I/O operations per second are performed (reads and writes). The transfers per second metric in conjunction with the kBytes per second value helps you to identify the average transfer size of the system. The average transfer size generally should match with the stripe size used by your disk subsystem.</p>
<h4 id="blocks-readwrite-per-second"><a href="#blocks-readwrite-per-second">Blocks read/write per second</a></h4>
<p>This metric depicts the reads and writes per second expressed in blocks of 1024 bytes as of kernel 2.6. Earlier kernels may report different block sizes, from 512 bytes to 4 KB.</p>
<h4 id="kilobytes-per-second-readwrite"><a href="#kilobytes-per-second-readwrite">Kilobytes per second read/write</a></h4>
<p>Reads and writes from/to the block device in kilobytes represent the amount of actual data transferred to and from the block device.</p>
</body>
</html>
